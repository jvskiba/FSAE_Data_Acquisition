// config.h

#ifndef CONFIG_H
#define CONFIG_H

struct CanSignal {
  uint16_t canId;
  uint8_t startByte;
  uint8_t length;
  bool littleEndian;
  float scale;
  float offset;
  String name;
};

struct LoggerConfig {
  uint16_t sampleRateHz;   // e.g. 100 Hz
  bool useNaNForMissing;   // true = write NaN, false = last known value
};

const char* ssid = "UGA_Motorsports";
const char* password = "formulaSAE";
const char* host = "192.168.0.3";
const uint16_t udpport = 5002;
const uint16_t tcpport = 5001;

// ===== Default CAN signal definitions =====
//id,startByte,length,littleEndian,scale,offset,name
CanSignal defaultSignals[] = {
  { 0x5F0, 0, 2, true,  0.25, 0.0, "RPM" },
  { 0x101, 2, 1, true,  1.00, 0.0, "Throttle" },
  { 0x102, 0, 2, true,  0.10, -40.0, "CoolantTemp" },
  { 0x200, 4, 2, false, 0.01, 0.0, "VehicleSpeed" }
};
const size_t defaultSignalCount = sizeof(defaultSignals) / sizeof(defaultSignals[0]);

// ===== Default logger config =====
LoggerConfig defaultConfig = {
  100,   // sampleRateHz (100 Hz)
  true   // useNaNForMissing
};


#endif


#include <SPI.h>
#include <mcp_can.h>
#include <SD.h>
#include <HardwareSerial.h>
#include <TinyGPSPlus.h>
#include <WiFi.h>
#include "config.h"

// --- PINS ---
#define CAN_CS   D7
#define SD_CS    D8

#define CAN_INT  D3
#define CAN_SCK  D4
#define CAN_MISO D6
#define CAN_MOSI D5

// ==== GPS CONFIG ====
const int gpsRXPin = D0;
const int gpsTXPin = D1;
const int ppsPin = D2;

volatile uint32_t ppsMicros = 0;
volatile uint32_t ppsMicrosLast = 0;
volatile bool ppsFlag = false;

unsigned long lastReconnectAttempt = 0;
const unsigned long RECONNECT_INTERVAL = 10000; // ms

MCP_CAN CAN(CAN_CS);
HardwareSerial GPSSerial(1);  // Use UART1

TinyGPSPlus gps;
File logfile;
portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;

// -- Interrupts --- 

void IRAM_ATTR onPPS() {
  portENTER_CRITICAL_ISR(&mux);
  ppsMicrosLast = ppsMicros;
  ppsMicros = micros();
  ppsFlag = true;
  portEXIT_CRITICAL_ISR(&mux);
}



void setup() {
  Serial.begin(115200);
  pinMode(ppsPin, INPUT);

  attachInterrupt(digitalPinToInterrupt(ppsPin), onPPS, RISING);
  GPSSerial.begin(9600, SERIAL_8N1, gpsRXPin, gpsTXPin);

  delay(1000);

  // --- Init SPI for both devices ---
  SPI.begin(CAN_SCK, CAN_MISO, CAN_MOSI);

  // --- Init CAN ---
  if (CAN.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) == CAN_OK) {
    Serial.println("MCP2515 Initialized Successfully!");
  } else {
    Serial.println("Error Initializing MCP2515...");
    while (1);
  }
  CAN.setMode(MCP_NORMAL);

  // --- Init SD card ---
  if (!SD.begin(SD_CS)) {
    Serial.println("Card Mount Failed");
    while (1);
  }
  Serial.println("SD card initialized.");

  // Open log file (append mode)
  logfile = SD.open("/canlog.txt", FILE_APPEND);
  if (!logfile) {
    Serial.println("Failed to open log file");
    while (1);
  }
  Serial.println("Logging to /canlog.txt");

  // Init Can Filtering
  CAN.init_Mask(0, 0, 0x7FF);     // Mask 0 (all bits must match)
  CAN.init_Filt(0, 0, 0x100);     // Accept ID 0x100

  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(ssid, password);
  unsigned long startTime = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\nWi-Fi connected!");
      Serial.print("ESP32 IP: ");
      Serial.println(WiFi.localIP());
  }
}

void loop() {
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    long unsigned int rxId;
    unsigned char len = 0;
    unsigned char rxBuf[8];

    CAN.readMsgBuf(&rxId, &len, rxBuf);

    // Format log line
    String logEntry = String(millis()) + ",ID:0x" + String(rxId, HEX) + ",DLC:" + String(len) + ",Data:";
    for (int i = 0; i < len; i++) {
      if (rxBuf[i] < 0x10) logEntry += "0";
      logEntry += String(rxBuf[i], HEX);
      if (i < len - 1) logEntry += " ";
    }
    logEntry += "\n";

    // Print to Serial
    Serial.print(logEntry);

    // Write to SD
    logfile.print(logEntry);

    // Flush occasionally to avoid data loss
    static unsigned long lastFlush = 0;
    if (millis() - lastFlush > 1000) {
      logfile.flush();
      lastFlush = millis();
    }
  }
}